/////////////////////////////////////////////////////////
// This class has been automatically generated on Mon Sep 1 19:12:16
// 2008 by ROOT version 5.18/00a from TTree OHltTree/ found on file:
// TEST.root
//////////////////////////////////////////////////////////

#ifndef OHltTree_h
#define OHltTree_h

#include <TROOT.h>
#include <TChain.h>
#include <TFile.h>
#include <TRandom3.h>
#include <TLorentzVector.h>
#include "Math/PtEtaPhiE4D.h"
#include "Math/PtEtaPhiM4D.h"
#include "Math/LorentzVector.h"

#include <vector>
#include <string>
#include <map>

#include "OHltConfig.h"
#include "OHltMenu.h"
#include "OHltRateCounter.h"

#include "L1GtLogicParser.h"
#include "LumiReweightingForRateEff.h"

#include "TH1.h"
#include "TH2.h"


class OHltTree
{
public:
   TTree *fChain; //!pointer to the analyzed TTree or TChain
   Int_t fCurrent; //!current Tree number in a TChain

   // logic parser for m_l1SeedsLogicalExpression
   std::vector<L1GtLogicParser*> m_l1AlgoLogicParser;

   reweight::LumiReWeighting LumiWeights_;
   
   L1GtLogicParser* m_preFilterLogicParser;
   
   void SetLogicParser(std::string l1SeedsLogicalExpression);

   // Declaration of leaf types

   Int_t NrecoJetCal;
   Int_t NrecoJetCorCal;
   Int_t NrecoJetGen;
   Int_t NrecoTowCal;


 
   Float_t recoJetCalPt[43000]; //[NrecoJetCal]
   Float_t recoJetCalPhi[43000]; //[NrecoJetCal]
   Float_t recoJetCalEta[43000]; //[NrecoJetCal]
   Float_t recoJetCalE[43000]; //[NrecoJetCal]
   Float_t recoJetCalEMF[43000]; //[NrecoJetCal]
   Float_t recoJetCalN90[43000]; //[NrecoJetCal]
   Float_t recoJetCalN90hits[43000]; //[NrecoJetCal]

   Float_t recoJetCorCalPt[43000]; //[NrecoJetCorCal]
   Float_t recoJetCorCalPhi[43000]; //[NrecoJetCorCal]
   Float_t recoJetCorCalEta[43000]; //[NrecoJetCorCal]
   Float_t recoJetCorCalE[43000]; //[NrecoJetCorCal]
   Float_t recoJetCorCalEMF[43000]; //[NrecoJetCal]
   Float_t recoJetCorCalN90[43000]; //[NrecoJetCal]
   Float_t recoJetCorCalN90hits[43000]; //[NrecoJetCal]

   Float_t recoJetGenPt[68000]; //[NrecoJetGen]
   Float_t recoJetGenPhi[68000]; //[NrecoJetGen]
   Float_t recoJetGenEta[68000]; //[NrecoJetGen]
   Float_t recoJetGenEt[68000]; //[NrecoJetGen]
   Float_t recoJetGenE[68000]; //[NrecoJetGen]
   Float_t recoTowEt[684000]; //[NrecoTowCal]
   Float_t recoTowEta[684000]; //[NrecoTowCal]
   Float_t recoTowPhi[684000]; //[NrecoTowCal]
   Float_t recoTowE[684000]; //[NrecoTowCal]
   Float_t recoTowEm[684000]; //[NrecoTowCal]
   Float_t recoTowHad[684000]; //[NrecoTowCal]
   Float_t recoTowOE[684000]; //[NrecoTowCal]

   Float_t recoMetCal;
   Float_t recoMetCalPhi;
   Float_t recoMetCalSum;
   Float_t recoMetGen;
   Float_t recoMetGenPhi;
   Float_t recoMetGenSum;
   Float_t recoHTCal;
   Float_t recoHTCalPhi;
   Float_t recoHTCalSum;
   Int_t recoNVrt; // reconstructed vertex info
   Int_t genNVrt; // generated vertex info
   Float_t recoVrtX[10]; //
   Float_t recoVrtY[10]; //
   Float_t recoVrtZ[10]; //
   Int_t recoVrtNtrk[10]; //
   Float_t recoVrtChi2[10]; //
   Float_t recoVrtNdof[10]; //
   Int_t NrecoElec;
   Float_t recoElecPt[4000]; //[NrecoElec]
   Float_t recoElecPhi[4000]; //[NrecoElec]
   Float_t recoElecEta[4000]; //[NrecoElec]
   Float_t recoElecEt[4000]; //[NrecoElec]
   Float_t recoElecE[4000]; //[NrecoElec]
   Int_t NrecoPhot;
   Float_t recoPhotPt[5000]; //[NrecoPhot]
   Float_t recoPhotPhi[5000]; //[NrecoPhot]
   Float_t recoPhotEta[5000]; //[NrecoPhot]
   Float_t recoPhotEt[5000]; //[NrecoPhot]
   Float_t recoPhotE[5000]; //[NrecoPhot]
	
   Int_t NrecoMuon;
   Float_t recoMuonPt[5000]; //[NrecoMuon]
   Float_t recoMuonPhi[5000]; //[NrecoMuon]
   Float_t recoMuonEta[5000]; //[NrecoMuon]
   Float_t recoMuonEt[5000]; //[NrecoMuon]
   Float_t recoMuonE[5000]; //[NrecoMuon]

   Int_t NMCpart;
   Int_t MCpid[1203000]; //[NMCpart]
   Int_t MCstatus[1203000]; //[NMCpart]
   Float_t MCvtxX[1203000]; //[NMCpart]
   Float_t MCvtxY[1203000]; //[NMCpart]
   Float_t MCvtxZ[1203000]; //[NMCpart]
   Float_t MCpt[1203000]; //[NMCpart]
   Float_t MCeta[1203000]; //[NMCpart]
   Float_t MCphi[1203000]; //[NMCpart]
   Float_t MCPtHat;
   Float_t MCWeight;
   Float_t MCWeightSign;
   Int_t MCmu3;
   Int_t MCel3;
   Int_t MCbb;
   Int_t MCab;
   Int_t MCWenu;
   Int_t MCWmunu;
   Int_t MCZee;
   Int_t MCZmumu;
   Float_t MCptEleMax;
   Float_t MCptMuMax;
   Int_t Run;
   Int_t Event;
   Int_t LumiBlock;
   Int_t Bx;
   Int_t Orbit;
   Double_t AvgInstDelLumi;


   // Autogenerated L1 - Int_t


   // Autogenerated L1 - Prescale Int_t

   // Autogenerated from ConfDB - Int_t


   // Autogenerated from ConfDB - Prescale Int_t






   // List of branches
   TBranch *b_NrecoJetCal; //!
   TBranch *b_NrecoJetCorCal; //!
   TBranch *b_NrecoJetGen; //!
   TBranch *b_NrecoTowCal; //!

   TBranch *b_recoJetCalPt; //!
   TBranch *b_recoJetCalPhi; //!
   TBranch *b_recoJetCalEta; //!
   TBranch *b_recoJetCalE; //!
   TBranch *b_recoJetCalEMF; //!
   TBranch *b_recoJetCalN90; //!
   TBranch *b_recoJetCalN90hits; //!

   TBranch *b_recoJetCorCalPt; //!
   TBranch *b_recoJetCorCalPhi; //!
   TBranch *b_recoJetCorCalEta; //!
   TBranch *b_recoJetCorCalE; //!
   TBranch *b_recoJetCorCalEMF; //!
   TBranch *b_recoJetCorCalN90; // !  
   TBranch *b_recoJetCorCalN90hits; // !  

   TBranch *b_recoJetGenPt; //!
   TBranch *b_recoJetGenPhi; //!
   TBranch *b_recoJetGenEta; //!
   TBranch *b_recoJetGenEt; //!
   TBranch *b_recoJetGenE; //!
   TBranch *b_recoTowEt; //!
   TBranch *b_recoTowEta; //!
   TBranch *b_recoTowPhi; //!
   TBranch *b_recoTowE; //!
   TBranch *b_recoTowEm; //!
   TBranch *b_recoTowHad; //!
   TBranch *b_recoTowOE; //!
   TBranch *b_recoMetCal; //!
   TBranch *b_recoMetCalPhi; //!
   TBranch *b_recoMetCalSum; //!
   TBranch *b_recoMetGen; //!
   TBranch *b_recoMetGenPhi; //!
   TBranch *b_recoMetGenSum; //!
   TBranch *b_recoHTCal; //!
   TBranch *b_recoHTCalPhi; //!
   TBranch *b_recoHTCalSum; //!
   TBranch *b_recoNVrt; //!
   TBranch *b_genNVrt; //!
   TBranch *b_recoVrtX; //!
   TBranch *b_recoVrtY; //!
   TBranch *b_recoVrtZ; //!
   TBranch *b_recoVrtNtrk; //!
   TBranch *b_recoVrtChi2; //!
   TBranch *b_recoVrtNdof; //!
   TBranch *b_NrecoElec; //!
   TBranch *b_recoElecPt; //!
   TBranch *b_recoElecPhi; //!
   TBranch *b_recoElecEta; //!
   TBranch *b_recoElecEt; //!
   TBranch *b_recoElecE; //!
   TBranch *b_NrecoPhot; //!
   TBranch *b_recoPhotPt; //!
   TBranch *b_recoPhotPhi; //!
   TBranch *b_recoPhotEta; //!
   TBranch *b_recoPhotEt; //!
   TBranch *b_recoPhotE; //!
   TBranch *b_NrecoMuon; //!
   TBranch *b_recoMuonPt; //!
   TBranch *b_recoMuonPhi; //!
   TBranch *b_recoMuonEta; //!
   TBranch *b_recoMuonEt; //!
   TBranch *b_recoMuonE; //!
   TBranch *b_NMCpart; //!
   TBranch *b_MCpid; //!
   TBranch *b_MCstatus; //!
   TBranch *b_MCvtxX; //!
   TBranch *b_MCvtxY; //!
   TBranch *b_MCvtxZ; //!
   TBranch *b_MCpt; //!
   TBranch *b_MCeta; //!
   TBranch *b_MCphi; //!
   TBranch *b_MCPtHat; //!
   TBranch *b_MCWeight; //!
   TBranch *b_MCWeightSign; //!
   TBranch *b_MCmu3; //!
   TBranch *b_MCel3; //!
   TBranch *b_MCbb; //!
   TBranch *b_MCab; //!
   TBranch *b_MCWenu; //!
   TBranch *b_MCmunu; //!
   TBranch *b_MCZee; //!
   TBranch *b_MCZmumu; //!
   TBranch *b_MCptEleMax; //!
   TBranch *b_MCptMuMax; //!
   TBranch *b_Run; //!
   TBranch *b_Event; //!
   TBranch *b_LumiBlock; //!
   TBranch *b_Bx; //!
   TBranch *b_Orbit; //!
   TBranch *b_AvgInstDelLumi; //!


   // Autogenerated L1 - TBranch 

   // Autogenerated from ConfDB - TBranch

   // Autogenerated L1 - Prescale TBranch 

   // Autogenerated from ConfDB - Prescale TBranch




   OHltTree(TTree *tree=0, OHltMenu *menu=0);
   
   virtual ~OHltTree();
   
   virtual Bool_t Notify();
   
   virtual void Init(TTree *tree);

   inline Int_t GetEntry(Long64_t entry);
   
   inline Long64_t LoadTree(Long64_t entry);
   
   inline void SetMapL1BitOfStandardHLTPath(OHltMenu *menu);
   
   inline void SetMapL1SeedsOfStandardHLTPath(OHltMenu *menu);
   
   inline void SetMapL1BitOfStandardHLTPathUsingLogicParser(
         OHltMenu *menu,
         int nentry);
   
   inline void ApplyL1Prescales(
         OHltMenu *menu,
         OHltConfig *cfg,
         OHltRateCounter *rc);
   
   inline void RemoveEGOverlaps();
   
   inline void SetL1MuonQuality();
   
   inline void SetOpenL1Bits();
   
   bool passPreFilterLogicParser(TString, int);

   void Loop(
         OHltRateCounter *rc,
         OHltConfig *cfg,
         OHltMenu *menu,
         int pID,
         double &Den,
         TH1F* &h1,
         TH1F* &h2,
         TH1F* &h3,
         TH1F* &h4,
         SampleDiagnostics& primaryDatasetsDiagnostics);

   

   int readRefPrescaleFromFile(TString st);

   std::map<TString, std::vector<TString> >& GetL1SeedsOfHLTPathMap()
   {
      return map_L1SeedsOfStandardHLTPath;
   }
   // mapping to all seeds

   int GetNLumiSections()
   {
      return nLumiSections;
   }


private:

   int nTrig;
   int nL1Trig;
   int nLumiSections;
   int previousLumiSection;
   int currentLumiSection;
   int nEventsProcessed;
   std::vector<int> triggerBit;
   std::vector<int> previousBitsFired;
   std::vector<int> allOtherBitsFired;
   std::vector<int> BitOfStandardHLTPath;

   std::map<TString,int> map_BitOfStandardHLTPath;
   std::map<TString,int> map_L1BitOfStandardHLTPath;
   std::map<TString,int> map_RefPrescaleOfStandardHLTPath;

   std::map<TString, std::vector<TString> > map_L1SeedsOfStandardHLTPath; // mapping to all seeds
   std::map<TString, std::vector<int> > map_RpnTokenIdOfStandardHLTPath; // mapping to algo token


   TRandom3 random; // for random prescale method
   
   inline int GetIntRandom()
   {
      return (int)(9999999.*random.Rndm());
   }
   
   inline int GetFloatRandom()
   {
      return (9999999.*random.Rndm());
   }

   bool prescaleResponse(
         OHltMenu *menu,
         OHltConfig *cfg,
         OHltRateCounter *rc,
         int i);
   
   bool prescaleResponseL1(
         OHltMenu *menu,
         OHltConfig *cfg,
         OHltRateCounter *rc,
         int i);
   
   bool isInRunLumiblockList(int, int, std::vector < std::vector <int> >);

   int nMissingTriggerWarnings;

   enum e_objType {
      muon,
      electron,
      tau,
      photon,
      jet};
};


#ifdef OHltTree_cxx

OHltTree::OHltTree(TTree *tree, OHltMenu *menu)
{
   random.SetSeed(0);

   std::cout<<"Initialising OHltTree."<<std::endl;
   if (tree == 0)
   {
      std::cerr<<"Error initialising tree!"<<std::endl;
      return;
   }
   if (menu == 0)
   {
      std::cerr<<"Error: no menu!"<<std::endl;
      return;
   }
   Init(tree);

   nMissingTriggerWarnings = 0;

   currentLumiSection = -999;
   previousLumiSection = -999;
   nLumiSections = 0;

   nTrig = menu->GetTriggerSize();
   nL1Trig = menu->GetL1TriggerSize();

   triggerBit.reserve(nTrig);
   previousBitsFired.reserve(nTrig);
   allOtherBitsFired.reserve(nTrig);
   BitOfStandardHLTPath.reserve(nTrig);

   for (int it = 0; it < nTrig; it++)
   {
      triggerBit.push_back(false);
      previousBitsFired.push_back(false);
      allOtherBitsFired.push_back(false);
   }
   std::cout<<"Succeeded initialising OHltTree. nEntries: "<<fChain->GetEntries()<<std::endl;

}


OHltTree::~OHltTree()
{
   if (!fChain) return;
   delete fChain->GetCurrentFile();
}

Int_t OHltTree::GetEntry(Long64_t entry)
{
   // Read contents of entry.
   if (!fChain) return 0;
   return fChain->GetEntry(entry);
}

Long64_t OHltTree::LoadTree(Long64_t entry)
{
   // Set the environment to read one entry
   if (!fChain) return -5;
   Long64_t centry = fChain->LoadTree(entry);
   if (centry < 0) return centry;
   if (!fChain->InheritsFrom(TChain::Class())) return centry;
   TChain *chain = (TChain*)fChain;
   if (chain->GetTreeNumber() != fCurrent)
   {
      fCurrent = chain->GetTreeNumber();
      Notify();
   }
   return centry;
}

void OHltTree::Init(TTree *tree)
{
   // The Init() function is called when the selector needs to initialize
   // a new tree or chain. Typically here the branch addresses and branch
   // pointers of the tree will be set.
   // It is normally not necessary to make changes to the generated
   // code, but the routine can be extended by the user if needed.
   // Init() will be called many times when running on PROOF
   // (once per file to be processed).

   // Set branch addresses and branch pointers
   if (!tree) return;
   fChain = tree;
   fCurrent = -1;
   fChain->SetMakeClass(1);

   fChain->SetBranchAddress("NrecoJetCal", &NrecoJetCal, &b_NrecoJetCal);
   fChain->SetBranchAddress("NrecoJetCorCal", &NrecoJetCorCal, &b_NrecoJetCorCal);

   fChain->SetBranchAddress("NrecoJetGen", &NrecoJetGen, &b_NrecoJetGen);
   fChain->SetBranchAddress("NrecoTowCal", &NrecoTowCal, &b_NrecoTowCal);

   fChain->SetBranchAddress("recoJetCalPt", recoJetCalPt, &b_recoJetCalPt);
   fChain->SetBranchAddress("recoJetCalPhi", recoJetCalPhi, &b_recoJetCalPhi);
   fChain->SetBranchAddress("recoJetCalEta", recoJetCalEta, &b_recoJetCalEta);
   fChain->SetBranchAddress("recoJetCalE", recoJetCalE, &b_recoJetCalE);
   fChain->SetBranchAddress("recoJetCalEMF", recoJetCalEMF, &b_recoJetCalEMF);
   fChain->SetBranchAddress("recoJetCalN90", recoJetCalN90, &b_recoJetCalN90);
   fChain->SetBranchAddress("recoJetCalN90hits", recoJetCalN90hits, &b_recoJetCalN90hits);

   fChain->SetBranchAddress("recoJetCorCalPt", recoJetCorCalPt, &b_recoJetCorCalPt);
   fChain->SetBranchAddress("recoJetCorCalPhi", recoJetCorCalPhi, &b_recoJetCorCalPhi);
   fChain->SetBranchAddress("recoJetCorCalEta", recoJetCorCalEta, &b_recoJetCorCalEta);
   fChain->SetBranchAddress("recoJetCorCalE", recoJetCorCalE, &b_recoJetCorCalE);
   fChain->SetBranchAddress("recoJetCorCalEMF", recoJetCorCalEMF, &b_recoJetCorCalEMF);
   fChain->SetBranchAddress("recoJetCorCalN90", recoJetCorCalN90, &b_recoJetCorCalN90);
   fChain->SetBranchAddress("recoJetCorCalN90hits", recoJetCorCalN90hits, &b_recoJetCorCalN90hits);

   fChain->SetBranchAddress("recoJetGenPt", &recoJetGenPt, &b_recoJetGenPt);
   fChain->SetBranchAddress("recoJetGenPhi", &recoJetGenPhi, &b_recoJetGenPhi);
   fChain->SetBranchAddress("recoJetGenEta", &recoJetGenEta, &b_recoJetGenEta);
   fChain->SetBranchAddress("recoJetGenEt", &recoJetGenEt, &b_recoJetGenEt);
   fChain->SetBranchAddress("recoJetGenE", &recoJetGenE, &b_recoJetGenE);
   fChain->SetBranchAddress("recoTowEt", &recoTowEt, &b_recoTowEt);
   fChain->SetBranchAddress("recoTowEta", &recoTowEta, &b_recoTowEta);
   fChain->SetBranchAddress("recoTowPhi", &recoTowPhi, &b_recoTowPhi);
   fChain->SetBranchAddress("recoTowE", &recoTowE, &b_recoTowE);
   fChain->SetBranchAddress("recoTowEm", &recoTowEm, &b_recoTowEm);
   fChain->SetBranchAddress("recoTowHad", &recoTowHad, &b_recoTowHad);
   fChain->SetBranchAddress("recoTowOE", &recoTowOE, &b_recoTowOE);

   fChain->SetBranchAddress("recoMetCal", &recoMetCal, &b_recoMetCal);
   fChain->SetBranchAddress("recoMetCalPhi", &recoMetCalPhi, &b_recoMetCalPhi);
   fChain->SetBranchAddress("recoMetCalSum", &recoMetCalSum, &b_recoMetCalSum);
   fChain->SetBranchAddress("recoMetGen", &recoMetGen, &b_recoMetGen);
   fChain->SetBranchAddress("recoMetGenPhi", &recoMetGenPhi, &b_recoMetGenPhi);
   fChain->SetBranchAddress("recoMetGenSum", &recoMetGenSum, &b_recoMetGenSum);
   fChain->SetBranchAddress("recoHTCal", &recoHTCal, &b_recoHTCal);
   fChain->SetBranchAddress("recoHTCalPhi", &recoHTCalPhi, &b_recoHTCalPhi);
   fChain->SetBranchAddress("recoHTCalSum", &recoHTCalSum, &b_recoHTCalSum);
   fChain->SetBranchAddress("NPUgenBX0", &genNVrt, &b_genNVrt);
   fChain->SetBranchAddress("recoNVrtOffline0", &recoNVrt, &b_recoNVrt);
   fChain->SetBranchAddress("recoVrtXOffline0", &recoVrtX, &b_recoVrtX);
   fChain->SetBranchAddress("recoVrtYOffline0", &recoVrtY, &b_recoVrtY);
   fChain->SetBranchAddress("recoVrtZOffline0", &recoVrtZ, &b_recoVrtZ);
   fChain->SetBranchAddress("recoVrtNtrkOffline0", &recoVrtNtrk, &b_recoVrtNtrk);
   fChain->SetBranchAddress("recoVrtChi2Offline0", &recoVrtChi2, &b_recoVrtChi2);
   fChain->SetBranchAddress("recoVrtNdofOffline0", &recoVrtNdof, &b_recoVrtNdof);

   fChain->SetBranchAddress("NrecoElec", &NrecoElec, &b_NrecoElec);
   fChain->SetBranchAddress("recoElecPt", &recoElecPt, &b_recoElecPt);
   fChain->SetBranchAddress("recoElecPhi", &recoElecPhi, &b_recoElecPhi);
   fChain->SetBranchAddress("recoElecEta", &recoElecEta, &b_recoElecEta);
   fChain->SetBranchAddress("recoElecEt", &recoElecEt, &b_recoElecEt);
   fChain->SetBranchAddress("recoElecE", &recoElecE, &b_recoElecE);
   fChain->SetBranchAddress("NrecoPhot", &NrecoPhot, &b_NrecoPhot);
   fChain->SetBranchAddress("recoPhotPt", &recoPhotPt, &b_recoPhotPt);
   fChain->SetBranchAddress("recoPhotPhi", &recoPhotPhi, &b_recoPhotPhi);
   fChain->SetBranchAddress("recoPhotEta", &recoPhotEta, &b_recoPhotEta);
   fChain->SetBranchAddress("recoPhotEt", &recoPhotEt, &b_recoPhotEt);
   fChain->SetBranchAddress("recoPhotE", &recoPhotE, &b_recoPhotE);
	
   fChain->SetBranchAddress("NrecoMuon", &NrecoMuon, &b_NrecoMuon);
   fChain->SetBranchAddress("recoMuonPt", &recoMuonPt, &b_recoMuonPt);
   fChain->SetBranchAddress("recoMuonPhi", &recoMuonPhi, &b_recoMuonPhi);
   fChain->SetBranchAddress("recoMuonEta", &recoMuonEta, &b_recoMuonEta);
   fChain->SetBranchAddress("recoMuonEt", &recoMuonEt, &b_recoMuonEt);
   fChain->SetBranchAddress("recoMuonE", &recoMuonE, &b_recoMuonE);

   fChain->SetBranchAddress("NMCpart", &NMCpart, &b_NMCpart);
   fChain->SetBranchAddress("MCpid", MCpid, &b_MCpid);
   fChain->SetBranchAddress("MCstatus", MCstatus, &b_MCstatus);
   fChain->SetBranchAddress("MCvtxX", MCvtxX, &b_MCvtxX);
   fChain->SetBranchAddress("MCvtxY", MCvtxY, &b_MCvtxY);
   fChain->SetBranchAddress("MCvtxZ", MCvtxZ, &b_MCvtxZ);
   fChain->SetBranchAddress("MCpt", MCpt, &b_MCpt);
   fChain->SetBranchAddress("MCeta", MCeta, &b_MCeta);
   fChain->SetBranchAddress("MCphi", MCphi, &b_MCphi);
   fChain->SetBranchAddress("MCPtHat", &MCPtHat, &b_MCPtHat);
   fChain->SetBranchAddress("MCWeight", &MCWeight, &b_MCWeight);
   fChain->SetBranchAddress("MCWeightSign", &MCWeightSign, &b_MCWeightSign);
   fChain->SetBranchAddress("MCmu3", &MCmu3, &b_MCmu3);
   fChain->SetBranchAddress("MCel3", &MCel3, &b_MCel3);
   fChain->SetBranchAddress("MCbb", &MCbb, &b_MCbb);
   fChain->SetBranchAddress("MCab", &MCab, &b_MCab);
   fChain->SetBranchAddress("MCWenu", &MCWenu, &b_MCWenu);
   fChain->SetBranchAddress("MCWmunu", &MCWmunu, &b_MCmunu);
   fChain->SetBranchAddress("MCZee", &MCZee, &b_MCZee);
   fChain->SetBranchAddress("MCZmumu", &MCZmumu, &b_MCZmumu);
   fChain->SetBranchAddress("MCptEleMax", &MCptEleMax, &b_MCptEleMax);
   fChain->SetBranchAddress("MCptMuMax", &MCptMuMax, &b_MCptMuMax);
   fChain->SetBranchAddress("Run", &Run, &b_Run);
   fChain->SetBranchAddress("Event", &Event, &b_Event);
   fChain->SetBranchAddress("LumiBlock", &LumiBlock, &b_LumiBlock);
   fChain->SetBranchAddress("Bx", &Bx, &b_Bx);
   fChain->SetBranchAddress("Orbit", &Orbit, &b_Orbit);
   fChain->SetBranchAddress("AvgInstDelLumi", &AvgInstDelLumi, &b_AvgInstDelLumi);

   // Autogenerated L1 - SetBranchAddressBits 

   // Autogenerated L1 - Prescale SetBranchAddressBits 

   // Autogenerated from ConfDB - SetBranchAddressBits

   // Autogenerated from ConfDB - Prescale SetBranchAddressBits

   // Autogenerated L1 - SetBranchAddressMaps 

   // Autogenerated L1 - Prescale SetBranchAddressMaps

   // Autogenerated from ConfDB - SetBranchAddressMaps

   // Autogenerated from ConfDB - Prescale SetBranchAddressMaps

   Notify();
}

void OHltTree::SetMapL1SeedsOfStandardHLTPath(OHltMenu *menu)
{
   map_L1SeedsOfStandardHLTPath = menu->GetL1SeedsOfHLTPathMap();
}

void OHltTree::ApplyL1Prescales(OHltMenu *menu, OHltConfig *cfg, OHltRateCounter *rc)
{
   TString st;
   unsigned int tt = menu->GetL1TriggerSize();
   for (unsigned int i=0;i<tt;i++)
   {
      st = menu->GetL1TriggerName(i);
      if (map_BitOfStandardHLTPath.find(st)->second == 1)
      {
         if (!prescaleResponseL1(menu,cfg,rc,i))
         {
            map_BitOfStandardHLTPath[st] = 0;
         }
      }
   }
}

void OHltTree::SetMapL1BitOfStandardHLTPath(OHltMenu *menu)
{
   int tt = 0;
   TString st;
   unsigned ts = menu->GetTriggerSize();
   for (unsigned int i=0;i<ts;i++)
   {
      st = menu->GetTriggerName(i);
      std::map< TString, std::vector<TString> >::const_iterator it = map_L1SeedsOfStandardHLTPath.find(st);
      if (it != map_L1SeedsOfStandardHLTPath.end())
      {
         tt = 0;
         unsigned ts2 = it->second.size();
         for (unsigned int j=0;j<ts2;j++)
         {
            tt += (map_BitOfStandardHLTPath.find((map_L1SeedsOfStandardHLTPath.find(st)->second)[j]))->second;
         }
      }
      map_L1BitOfStandardHLTPath[st] = tt;
   }
}


void OHltTree::SetMapL1BitOfStandardHLTPathUsingLogicParser(OHltMenu *menu, int nentry)
{
   typedef std::vector<TString> myvec;
   typedef std::pair< TString, std::vector<TString> > mypair;
   typedef std::pair< TString, std::vector<int> > mypair2;
   myvec vtmp;
   std::vector<int> vtokentmp;

   TString st, l1st, seeds;
   unsigned ts = menu->GetTriggerSize();
   unsigned l1ts = menu->GetL1TriggerSize();
   //  std::cout<<"########################### \n";
   //  std::cout <<  "@@@ Level1GTSeedResult\n";

   if (nentry == 0)
   { // do this only for first event - speed up code!
      for (unsigned int i=0;i<ts;i++)
      {
         vtmp.clear();
         vtokentmp.clear();
         st = menu->GetTriggerName(i);
         seeds = menu->GetSeedCondition(st);

         //if (seeds != "") continue; // if no seeds skip to avoid error messages

         SetLogicParser((std::string) seeds);

         //      std::cout << "Trigger name: " << st << std::endl;
         //      std::cout << "Seed condition: " << seeds << std::endl;

         std::vector<L1GtLogicParser::OperandToken>& algOpTokenVector =
         (m_l1AlgoLogicParser[i])->operandTokenVector();

         //std::cout<<"@@@@@@@@@@@@ "<<st<<std::endl;

         for (unsigned int j=0;j<l1ts;j++)
         {
            l1st = menu->GetL1TriggerName(j);

            for (size_t k = 0; k < algOpTokenVector.size(); ++k)
            {
               bool iResult = false;
               //	  std::cout << "Token name: " << (algOpTokenVector[k]).tokenName << std::endl;
               if (l1st.CompareTo((algOpTokenVector[k]).tokenName) == 0)
               {
                  if (map_BitOfStandardHLTPath.find(l1st)->second==1)
                  iResult = true;
                  else
                  iResult = false;

                  //	    std::cout << "Token result: " << map_BitOfStandardHLTPath.find(l1st)->second << std::endl;
                  //	    std::cout << "Token result: " << iResult << std::endl;
                  (algOpTokenVector[k]).tokenResult = iResult;
                  vtmp.push_back(l1st);
                  vtokentmp.push_back((int)k);
               }
            }
         }
         map_L1SeedsOfStandardHLTPath.insert(mypair(st, vtmp));
         map_RpnTokenIdOfStandardHLTPath.insert(mypair2(st, vtokentmp));

         bool seedsResult = (m_l1AlgoLogicParser[i])->expressionResult();

         //      std::cout << "Expression result: " << seedsResult << std::endl;

         if (seedsResult)
         map_L1BitOfStandardHLTPath[st] = 1;
         else
         map_L1BitOfStandardHLTPath[st] = 0;
      }
   }
   else
   {
      for (unsigned int i=0;i<ts;i++)
      {
         st = menu->GetTriggerName(i);
         seeds = menu->GetSeedCondition(st);

         if (seeds == "") continue; // 

         std::vector<L1GtLogicParser::OperandToken>& algOpTokenVector =
         (m_l1AlgoLogicParser[i])->operandTokenVector();

         //      std::cout << "************** " << st << " " << nentry << std::endl;

         std::map< TString, std::vector<TString> >::const_iterator it = map_L1SeedsOfStandardHLTPath.find(st);

         if (it != map_L1SeedsOfStandardHLTPath.end())
         {
            unsigned ts2 = it->second.size();
            //	std::cout << "########## " << ts2 << std::endl;
            for (unsigned int j=0;j<ts2;j++)
            {
               //	  std::cout << "               " << it->second[j] << std::endl;
               bool iResult = false;
               if ((map_BitOfStandardHLTPath.find(it->second[j])->second)==1)
               iResult = true;
               else
               iResult = false;

               (algOpTokenVector[ (map_RpnTokenIdOfStandardHLTPath.find(st))->second[j] ]).tokenResult = iResult;

            }
         }

         bool seedsResult = (m_l1AlgoLogicParser[i])->expressionResult();
         //      std::cout << "Expression result: " << seedsResult << std::endl;

         if (seedsResult)
         map_L1BitOfStandardHLTPath[st] = 1;
         else
         map_L1BitOfStandardHLTPath[st] = 0;
      }
   }

}

bool OHltTree::passPreFilterLogicParser(TString str, int nentry)
{

   if (str == "") return true;

   if (nentry == 0)
   { // do this only for first event - speed up code!
      m_preFilterLogicParser = new L1GtLogicParser((std::string)str);
   }

   //cout<<  map_BitOfStandardHLTPath["HLT_Activity_L1A"]<<std::endl;

   //std::cout << "Token string: " << (std::string)str << std::endl;

   std::vector<L1GtLogicParser::OperandToken>& prefOpTokenVector =
   m_preFilterLogicParser->operandTokenVector();

   //std::cout << "Token size: " << prefOpTokenVector.size() << std::endl;
   for (size_t k = 0; k < prefOpTokenVector.size(); ++k)
   {
      bool iResult = false;
      //std::cout << "Token name: " << (prefOpTokenVector[k]).tokenName << std::endl;
      if (map_BitOfStandardHLTPath.find((prefOpTokenVector[k]).tokenName)->second==1)
      iResult = true;
      else
      iResult = false;
      //std::cout << "Token result: " << iResult << std::endl;

      (prefOpTokenVector[k]).tokenResult = iResult;
   }
   bool expResult = m_preFilterLogicParser->expressionResult();
   //bool expResult = true;

   if (expResult)
   return true;
   else
   return false;

}

Bool_t OHltTree::Notify()
{
   // The Notify() function is called when a new file is opened. This
   // can be either for a new TTree in a TChain or when when a new TTree
   // is started when using PROOF. It is normally not necessary to make changes
   // to the generated code, but the routine can be extended by the
   // user if needed. The return value is currently not used.

   return kTRUE;
}

#endif // #ifdef OHltTree_cxx

#endif // #ifdef OHltTree_h
